1.内联函数定义：
内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。
内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。（编译器自己判断，所以加了 inline也不一定是）
编译时，类似宏替换，使用函数体替换调用处的函数名。
一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。
inline int A (int x) { return 2*x; }
在类定义中定义的函数都是内联，否则需要说明
2.
把对象作为实参传给函数。例如： 
void f(Date d) //创建一个对象d，其数据成员用实参对象
			       //的成员对其初始化
{ ...... }
void g(Date &d) //不创建新对象，d就是实参对象！
{ ...... }
void h(const Date &d) //不创建新对象，d就是实参对象！
					//函数中不允许修改对象d！
{ ...... }
Date today;
f(today); //调用函数f，对象today不会被f修改
g(today); //调用函数g，对象today会被g修改！
h(today); //调用函数h，对象today不会被h修改
把对象作为函数的返回值。例如，
Date f(Date &d)
{ ......
   return d;  //创建一个临时对象作为返回值，用d对其初始化
}
Date& g(Date &d)
{ ......
   return d;  //不创建新对象，把对象d作为返回值
}
把对象作为函数的返回值。例如，
Date f(Date &d)
{ ......
   return d;  //创建一个临时对象作为返回值，用d对其初始化
}
Date& g(Date &d)
{ ......
   return d;  //不创建新对象，把对象d作为返回值
}
Date some_day(2000,1,1); //创建一个日期对象
f(some_day).set(2017,3,13); //some_day的日期是？
g(some_day).set(2017,3,13); //some_day的日期是？
//前者修改的是临时对象，后者修改的是some_day!
3.
成员对象由成员对象类的构造函数初始化：
通常是自动调用成员对象类的默认构造函数。
如果要调用成员对象类的非默认构造函数，需要在包含成员对象的类构造函数的成员初始化表中显式指出！
4.创建包含成员对象的类的对象时，
先执行成员对象类的构造函数，再执行本身类的构造函数。
从实现上说，是先调用本身类的构造函数，但在进入函数体之前，会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体！
一个类若包含多个成员对象，这些对象的构造函数调用次序按它们在类中的说明次序（而不是成员初始化表中的次序）进行。
注意：成员初始化表（即使是空）也可能包含代码！（编译自动加默认构造函数的目的！）
5.成员对象的拷贝构造函数
6.
可通过静态数据成员来实现属于同一个类的不同对象之间的数据共享：
class A
{ ......
   static int x; //静态数据成员
   void f()   { x++; ......   }
};
int A::x=0; //静态数据成员初始化
......
A a,b;
a.f();
b.f();
//上述操作对同一个x进行
x++; //Error，不通过A类对象不能访问x！
静态成员函数只能访问类的静态成员。
静态成员函数没有隐藏的this参数！
静态成员函数可以通过对象来访问外，也可以直接通过类来访问。


